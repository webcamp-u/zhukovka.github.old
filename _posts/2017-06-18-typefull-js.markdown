---
layout: post
title: "Строгий JavaScript"
subtitle: Почему и кому это надо
date: 2017-08-18 21:39:51 +0300
description: Зачем нам нужен typefull javascript
categories: js typescript trending
video: https://www.youtube.com/embed/XJiRqW2Gf6o
thumb: http://img.youtube.com/vi/XJiRqW2Gf6o/maxresdefault.jpg
tags: blog
---

Данные из Github за последние 3 года показывают существенный рост количества проектов, написанных с помощью инструментов, которые добавляют в JavaScript статической типизации. Конечно, можно предположить, что использованию, например, TypeScript способствовал выход фреймворка Angular2, который настоятельно рекомендовал использовать именно TypeScript, однако, существует немало проектов, которые используют совершенно другой фреймворк - ReactJS, при этом написаны на TypeScript. К тому же, Facebook разработал собственный инструмент для статической типизации JavaScript - Flow, которым рекомендует пользоваться для своего фреймворка ReactJS.

![js vs typescript chart](/assets/images/typefull-js/chart1.png)

Такое широкое распространение статических надстроек над динамическим JavaScript-ом заставляет задуматься: “Зачем и кому это надо?”.

## Небольшой экскурс в историю появления JavaScript

Мы все знаем, что JavaScript был создан в 1995 году Бренданом Эйхом для браузера Нетскейп навигатор. Автор говорил, что на его работу повлияли такие популярные в то языки программирования как Scheme, Self, Java и Smalltalk [источник](https://brendaneich.com/2008/04/popularity/), примечательно, что все эти языки имеют строгую типизацию. Так почему же JavaScript получился таким слабо типизированным?

Возможно, эта цитата автора поможет понять:
> “HTML нуждался в «язык сценариев», языке программирования, который был бы прост в использовании любителями и новичками, где код мог быть написан непосредственно в исходной форме как часть разметки веб-страницы. Мы стремились предоставить «язык-прослойку» для веб-дизайнеров и программистов-любителей, которые строят веб-контент из таких компонентов, как изображения, плагины и апплеты Java. Мы рассматривали Java как «компонентный язык», используемый более опытными программистами, тогда как программисты прослойки - разработчики веб-страниц - собирали бы компоненты и автоматизировали бы их взаимодействия с помощью JS.” - Брендан Эйх [источник](https://www.computerworld.com.au/article/255293/a-z_programming_languages_javascript/)

Брендан сильно бы удивился, если бы ему тогда сказали, что пройдет 20 лет и все браузеры откажутся от использования Java апплетов, а JavaScript станет самым популярным языком.

JavaScript оставался несерьезным языком для веб-дизайнеров до 2004 года, когда Google используя технологию AJAX выпустили в массовое потребление Gmail. Для своего почтовика Google уже не использовали чистый JS, они придумали набор инструментов Google Web Toolkit [источник](http://www.gwtproject.org/), который преобразовывал Java в JavaScript. Основной целью GWT заявлял кроссбраузерность, свободу от изучения JavaScript, а также общий код для бэкенда и фронтенда (single code base).

Каждый год какая-нибудь компания придумывала свои инструменты по преобразованию других языков в JavaScript, их более сотни и их объединяют цели и задачи, которые ставил перед собой и GWT. [источник](https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-js)

Все эти решения объединяла одна особенность - они были созданы для программистов, которые большую часть времени работали с другими языками и не хотели переключаться на JavaScript.

В 2011 году появился TypeScript - относительно самостоятельный язык (под сильным влиянием C#) специально для JavaScript разработчиков, главной задачей которого была именно статическая типизация для JS. В 2014 подобное решение, Flow, представили и в Facebook.

## Почему?

Так почему же гиганты индустрии Google, Microsoft и Facebook занимаются одним делом - добавляют статической или строго типизации JavaScript?

Здесь можно указать на несколько причин.

### Найти ошибки на этапе компиляции

JavaScript не требует компиляции, а слабая динамическая типизация делает практически невозможным анализ кода для IDE, по этой причине, мы можем столкнуться с ошибкой, связанной именно с типами данных, только в определенный случаях во время работы программы. Это усложняет процесс отладки продукта.
Даже самый опытный разработчик на JavaScript не всегда может сказать каким будет результат выполнения следующих операций:

<script src="https://gist.github.com/zhukovka/6e504f3399b587887360eb38c4791dd0.js"></script>

В таких случаях хотелось бы получать сообщение об ошибке уже в процессе написания кода даже в самом простом редакторе, как это позволяет TypeScript или Flow с бесплатным редактором Atom.

![object + array type error](/assets/images/typefull-js/object+array.png)

### Более читаемый код

  Часто статические языки критикуют за обилие указателей на тип данных, которые якобы мешают читаемости кода, однако типы явно, а главное всегда правильно, указывают разработчику на правила использования кода.

  Вот простой пример кода, достаточно простой, чтобы разработчик решил, что здесь все предельно понятно: есть продукт, у него есть категория, зачем тут указывать типы?

 <script src="https://gist.github.com/zhukovka/85674f5a5e99f64ebdb2d162672bbebf.js"></script>

  Однако, когда коллега автора этого кода или сам автор спустя некоторое время решает написать функцию поиска продукта по категории:

 <script src="https://gist.github.com/zhukovka/fb34ce0856c18181709a1408f7ee135d.js"></script>

  Здесь возникает проблема: “А что такое категория? И как написать сравнение?”. Может быть, что категория - это строка, или число или объект…
  TypeScript или Flow позволяют нам явно указать тип параметра и тем самым однозначно решить подобные вопросы.

<script src="https://gist.github.com/zhukovka/dc747c1d0afff33f36d6d50a459a5583.js"></script>

### Код, которым легче управлять

  Изменения в коде - обычная рутина для программиста, очень важно, чтобы эта работа происходила максимально безболезненно, но JavaScript - это не тот случай. Имея достаточно большой объем кода, особенно разделенный на несколько файлов или слишком общие названия переменных, изменения в код могут быть задачей очень нетривиальной. Рефакторинг становится значительно проще, если использовать TypeScript или Flow, ваш редактор может автоматически изменить название переменной или метода во всех местах, где вы их используете.

## Почему нет?

  Указанные три причины достаточны для того, чтобы значительно облегчить жизнь разработчика, однако есть и другой взгляд на этот вопрос. Есть аргументы против использования статической типизации для JavaScript.

### Вы не знаете JavaScript

  В предисловии к книге Кайла Симпсона “Вы не знаете JavaScript: Типы и грамматика” Девид Волш пишет:
  “JavaScript - единственный язык, который разработчики не учат перед тем как начать использовать.”
  Противники строгого JavaScript говорят, что люди пользуются инструментами для статической типизации просто потому, что не знают как пользоваться JS.

  Например, Эрик Эллиот говорит:
  “В динамически типизированном языке нет необходимости в конструкторах типов... Вместо этого разработчики могут использовать duck typing и, возможно, выполнять проверки типа времени выполнения.” [источник](https://medium.com/javascript-scene/you-might-not-need-typescript-or-static-types-aa7cb670a77b)

  Для примера Эллиот предлагает такую функцию для проверки наличия обязательных параметров:
<script src="https://gist.github.com/ericelliott/04ef5f90b4268598f73a75151af0684f.js"></script>

Кроме того, что эта функция объемная и сложная для чтения, невероятно странно, что она призвана решить задачу, с которой TypeScript или Flow справляется без лишних усилий со стороны программиста, то есть, просто сообщить об отсутсвии необходимого параметра.

![mandatory parameters](/assets/images/typefull-js/mandatory-parameters.png)

Дуглас Крокфорд, автор знаменитой книги “JavaScript лучшие стороны”, так отзывается о статических типах в JS:
“Я нашел в своей работе, что ошибки, которые обнаруживает строгая проверка типов, не являются ошибками, о которых я беспокоюсь. С другой стороны, я нахожу свободную типизацию либеральной. Мне не нужно создавать сложные иерархии классов. И мне никогда не приходится преобразовывать или бороться с системой типов, чтобы получить то поведение, которое я хочу.”

Для примера, Крокфорд считает, что код как этот не соответствует духу JavaScript
<script src="https://gist.github.com/zhukovka/716de4ef8bc321a06dd546b1ad34d6e6.js"></script>

И предлагает такую конструкцию, для того чтобы преобразовать число с запятой (float) в целое число (int):
<script src="https://gist.github.com/zhukovka/6210edb39d1f273732c0f4ffb57823ed.js"></script>

При всем желании тяжело принять подобные альтернативы для решений проблем связанных с отсутствием статической или строгой типизации в JavaScript, тем более, что современные популярные инструменты TypeScript и Flow не лишают JS его знаменитой гибкости, при этом добавляют полезной организованности как коду, так и разработчику.
